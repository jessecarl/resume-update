// generated by jsonenums -type=SkillType; DO NOT EDIT

package main

import (
	"encoding/json"
	"fmt"
)

var (
	_SkillTypeNameToValue = map[string]SkillType{
		"fluent":     fluent,
		"proficient": proficient,
		"competent":  competent,
		"familiar":   familiar,
	}

	_SkillTypeValueToName = map[SkillType]string{
		fluent:     "fluent",
		proficient: "proficient",
		competent:  "competent",
		familiar:   "familiar",
	}
)

func init() {
	var v SkillType
	if _, ok := interface{}(v).(fmt.Stringer); ok {
		_SkillTypeNameToValue = map[string]SkillType{
			interface{}(fluent).(fmt.Stringer).String():     fluent,
			interface{}(proficient).(fmt.Stringer).String(): proficient,
			interface{}(competent).(fmt.Stringer).String():  competent,
			interface{}(familiar).(fmt.Stringer).String():   familiar,
		}
	}
}

// MarshalJSON is generated so SkillType satisfies json.Marshaler.
func (r SkillType) MarshalJSON() ([]byte, error) {
	if s, ok := interface{}(r).(fmt.Stringer); ok {
		return json.Marshal(s.String())
	}
	s, ok := _SkillTypeValueToName[r]
	if !ok {
		return nil, fmt.Errorf("invalid SkillType: %d", r)
	}
	return json.Marshal(s)
}

// UnmarshalJSON is generated so SkillType satisfies json.Unmarshaler.
func (r *SkillType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("SkillType should be a string, got %s", data)
	}
	v, ok := _SkillTypeNameToValue[s]
	if !ok {
		return fmt.Errorf("invalid SkillType %q", s)
	}
	*r = v
	return nil
}
